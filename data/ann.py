# -*- coding: utf-8 -*-
"""ann.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jODo8-KYLxPUlhVAo_gbKchaVkTwJ23V
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import math
from scipy.stats import norm
import time
import pandas as pd
import statsmodels.api as sm
from keras.layers import Dense, Dropout, LSTM, Embedding
from keras.models import Sequential
from matplotlib import pyplot as plt

# %matplotlib inline

# Transmited label data file
from google.colab import files
import io
#number of receiverd particle
uploadedy = files.upload()

data = pd.read_csv('x_y.csv')

X = data['X']
Y = data["Y"]

print(X)

X = np.array(data['X'])
X = np.reshape(X, (5500,1))
Y = np.array(data['Y'])
Y = np.reshape(Y, (5500,1))

from keras.optimizers import Adam
model = Sequential()

model.add(Dense(5, input_dim=1, activation='tanh'))
for i in range(8):
  model.add(Dense(5, input_dim=5, activation='tanh'))
model.add(Dense(1, input_dim=5, activation='sigmoid'))

model.compile(loss='binary_crossentropy',optimizer=Adam(lr=0.01),metrics=['accuracy'])

mymodel = model.fit(X[:3000],Y[:3000],epochs=50,batch_size=10)
scores = model.evaluate(X, Y)
print(model.metrics_names)
print(scores)

print(mymodel.history.keys())
# summarize history for accuracy
plt.plot(mymodel.history['accuracy'])
# plt.plot(mymodel.history['val_accuracy'])
plt.title('model accuracy for ANN')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.savefig('ann_accu')
# plt.legend(['train', 'test'], loc='upper left')
plt.show()
 #summarize history for loss
plt.plot(mymodel.history['loss'])
# plt.plot(mymodel.history['val_loss'])
plt.title('model loss for ANN')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.savefig('ann_loss')
# plt.legend(['train', 'test'], loc='upper left')
plt.show()

pd_FM = {}
idx=0
X_FM_lb=[]
for snr in range(-5, 50, 1):
  X_FM_lb.append(X[idx:idx+100])
  idx=idx+100

#print(X_FM_lb)


for snr in range(-5, 50, 1):
  y_snr = np.ones((X_FM_lb[snr+5].shape[0], 1))
  scores = model.evaluate(X_FM_lb[snr+5], y_snr)
  # print(scores)
  print("At SNR = " + str(snr) + "\n%s: %.2f%%" % (model.metrics_names[1], scores[1]*100))
  pd_FM[snr] =(1- scores[1])/2
  
plt.plot(range(-5, 50, 1), list(pd_FM.values()))

# printing the graph
plt.yscale('log')
plt.xlabel('SNR Range')
plt.ylabel('BER')
plt.grid()
plt.savefig('ann_orig')
plt.legend(loc='upper right',ncol = 1)
plt.savefig('snip')
plt.show()

